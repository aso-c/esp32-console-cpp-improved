//
// iostream extentions for advanced formatting &
// additional compatibility with C stdio layer.
//
// extra_stream
// Header file
//
// author: Solomatov A.A. (aso)
// ver.  : v.0.1
// date  : 07.06.22.
//


#ifndef __EXTRA_STREAM_ASO__
#define __EXTRA_STREAM_ASO__


namespace aso
{



    // Sources (in russian):
    // https://overcoder.net/q/54881/получение-файла-из-std-fstream
    // https://overcoder.net/q/54881/%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%B8%D0%B7-std-fstream
    // https://ask-dev.ru/info/113124/getting-a-file-from-a-stdfstream
    //
    // Original:
    // Implementation may not be fully cross-platform, but simple
    //
    // Simple crack:  http://www.ginac.de/~kreckel/fileno/ (reply dvorak) & see this extention:
    // gcc http://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a00069.html#a59f78806603c619eafcd4537c920f859,
    // There is a solution, that works at GCC (> 4.8) & clang (at least, 3.3)
    // [...]
    //
    // Usage:
    //
    // #include <stdio.h>
    //
    // #include <fstream>
    // #include <ext/stdio_filebuf.h>
    //
    // /* [ -->  #include "include/extra_stream" <-- Not needeed on user file? ]
    //
    //
    // int main(){
    //     std::ofstream ofs("file.txt");
    //     fprintf(cfile(ofs), "sample1");
    //     fflush(cfile(ofs)); // ofs << std::flush; doesn't help
    //     ofs << "sample2\n";
    // }
    // Flushing C file after output on it & before output to tied C++ fstream - is strongly recommended!
    //


    // Get C File, tied with passed ofstream
    FILE* cfile(std::ofstream const& ofs);

    // Get C File, tied with passed ifstream
    FILE* cfile(std::ifstream const& ifs);

    // Overloads for cout, cerr & clog iostreams
    FILE* cfile(std::ostream const& os);

    // Overloads for cin iostreams
    FILE* cfile(std::istream const& is);

//    class format
//    {
//    public:
//	format (const char*);
//	
//    protected:
//	const char *fmt_str;
//	
//	friend std::ostream& operator << (std::ostream&, const format&);
//
//    }; /* format */
//
//    
//	std::ostream& operator << (std::ostream &os, const format &fmt);


// Implementation of the 'format' procedeure
    template <typename OutStream, typename... PrnTypes>
//    inline int format_impl(std::ofstream& os, const char* format_str, PrnTypes&&... prn_values)
    inline int format_impl(OutStream& os, const char* format_str, PrnTypes&&... prn_values)
    { return fprintf(cfile(os), format_str, prn_values... );};

//    template <typename... PrnTypes>
//    inline int format_impl(std::ostream& os, const char* format_str, PrnTypes&&... prn_values)
//    { return fprintf(cfile(os), format_str, prn_values... );};

//    template </*typename OutStream,*/ const char* fmt_str, typename... PrnTypes>
////    template </*typename OutStream, const std::string &fmt_str,*/ typename... PrnTypes>
//    //constexpr decltype(auto) curryN(F&& f, Args&&... args) const;
    class Formatter
    {
    public:
	virtual int Run(std::ostream&) = 0;
	virtual int Run(std::ofstream&) = 0;
	virtual ~Formatter() {};
////	template <typename OutStream, const char* fmt_str, PrnTypes&&... prnvalues>
////	OutStream& operator() (OutStream& os) {format_impl(os, fmt_str, prnvalues...); return os;};
//	template <typename OutStream/*, const char* fmt_str*/>
//	OutStream& exec(OutStream& os) {implementation(os); return os;};
//	//constexpr decltype(auto) operator()(As&&... as) const;

//    private:
//	template <typename OutStream, OutStream os, PrnTypes&&... prnvalues>
//	int implementation(/*OutStream& oss*/) {return format_impl(os, fmt_str, prnvalues...);};
    }; /* Formatter */


    template <typename... fmt_Types>
    class inFormat: public Formatter
    {
    public:
	int Run(std::ostream& os) {return 0;}
	int Run(std::ofstream& os) {return 0;}
	;
    }; /* inFormat */


// Test
    int inline sum2(int lhs, int rhs) {
      return lhs + rhs;
    }

////    auto inline curried_sum2(int lhs) {
//    inline int (*curried_sum2(int lhs))(int)
//    {
////      return [=](int rhs) {
////        return sum2(lhs, rhs);
////      };
//	return std::bind( sum2, lhs  );
//    }

#if 1
#if 0
    // aso::format with variadic parameters implementation, variant 3
//    template </*typename OutStream,*/ /*const char* fmt_str,*/ typename... PrnTypes>
//    OutStream& (*format(const char* format_str, PrnTypes&&... prnparams))(OutStream&)
//    std::ostream& (*format(const char* format_str, PrnTypes&&... prnparams))(std::ostream&)
    //std::ostream& (*format(const char* format_str, ...))(std::ostream&)
    decltype([=](std::ostream& os){return os;}) format(const char* format_str, ...)
    {
	std::cout << "Proverka vyzova functcii 'aso::format" << std::endl;
	return [=](std::ostream& os) {return os;};
//	return [=](OutStream& os) {return os;};
    }; /* format */
#endif

#else

    // aso::format with variadic parameters implementation
    template <typename OutStream, /*const char* fmt_str,*/ typename... PrnTypes>
    inline Formatter&&
    format(const char* format_str, PrnTypes&&... prnparams)
    {

	ret = inFormat<...prnparams>;
	return ret;
    }; /* format*/

    #endif

#if 0
// Template for the iostream manipulator
// that implemented partial application of the function callfunc
// with fixing ParamType parameter
//template <typename ParamType, ostream& (*callfunc)(ostream&, ParamType)>
template <typename... OutTypes>
//ostream& (*format(ParamType value))(ostream&)
//ostream& (*format(const std::string &str_format, OutTypes... prn_params))(ostream&)
std::ofstream& (*format(const char* str_format, OutTypes&&... prn_params))(std::ofstream&)
{
	static ParamType val = 0;
	struct PartApp { static ostream& exec(ostream& out) {return callfunc(out, val);}; };

    val = value;
    return PartApp::exec;
}; /* format */
#endif


}; /* namespace aso */



#endif // __EXTRA_STREAM_ASO__
